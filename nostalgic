#!/usr/bin/env bash

# ** The MIT License **
#
# Copyright (c) 2012-2025 Eric Davis
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Home: https://github.com/insanum/nostalgic
#
# Author: Eric Davis <http://insanum.com>
# My dotfiles: https://github.com/insanum/dotfiles
#
# Dude... just buy me a beer. :-)
#

REPOS=$HOME/dots
DEST=$HOME
DRYRUN=0
SKIP_CONFLICTS=0
FIX_CONFLICTS=0
PREFIXED=0

function log_red()     { echo -e "\e[1;31m$*\e[0m"; }
function log_green()   { echo -e "\e[1;32m$*\e[0m"; }
function log_yellow()  { echo -e "\e[1;33m$*\e[0m"; }
function log_blue()    { echo -e "\e[1;34m$*\e[0m"; }
function log_magenta() { echo -e "\e[1;35m$*\e[0m"; }
function log_cyan()    { echo -e "\e[1;36m$*\e[0m"; }

function err()
{
    echo -e "\e[1;31mERROR: $*\e[0m"
    exit 1
}

# Run a command only if not in dry-run mode
# $@: command and arguments
function run()
{
    [[ $DRYRUN -eq 1 ]] && return 0
    "$@"
}

# Get the repo name from a git URL
# $1: git URL (e.g. https://github.com/user/repo.git)
function parse_url()
{
    local url="${1%.git}"
    echo "${url##*/}"
}

# Clone a git repository into $REPOS
# $1: git URI to clone
function clone()
{
    [[ -z "$1" ]] && err "clone requires an argument"

    local repo="$REPOS/$(parse_url "$1")"
    [[ -e "$repo" ]] && err "$repo exists"

    log_green "--> cloning [$repo]"
    run git clone "$1" "$repo" || err "failed to clone $1"
}

# List all cloned repositories
function list()
{
    local found=0
    for repo in "$REPOS"/*; do
        [[ ! -d "$repo" ]] && continue
        found=1
        local origin=$(cd "$repo" && git config remote.origin.url 2>/dev/null)
        log_green "--> repo [$repo] cloned from [$origin]"
    done
    [[ $found -eq 0 ]] && log_yellow "(no repos found)"
}

# Check if a directory is a valid git repository
# $1: repo path
# $2: operation name (for error message)
function repo_exists()
{
    [[ -d "$1" && -d "$1/.git" ]] || err "could not $2 $1 (repo does not exist)"
}

# Execute a function for a repo or all repos
# $1: function to call
# $2: repo name or 'ALL'
# $3: command name (for error message)
function for_each_repo()
{
    local func=$1
    local arg=$2
    local cmd=$3

    [[ -z "$arg" ]] && err "$cmd requires an argument"

    if [[ "$arg" == ALL ]]; then
        for repo in "$REPOS"/*; do
            [[ ! -d "$repo" ]] && continue
            "$func" "$repo"
        done
    else
        "$func" "$REPOS/$arg"
    fi
}

# Ensure a directory exists (create if needed, respects dry-run)
# $1: directory path
function ensure_dir()
{
    [[ -d "$1" ]] && return
    [[ $DRYRUN -eq 0 ]] && mkdir -p "$1"
    log_green "--> mkdir [$1]"
}

# Git pull for a single repository
# $1: repo path
function pull_repo()
{
    repo_exists "$1" 'pull'
    log_green "--> git pull for repo [$1]"
    run sh -c "cd '$1' && git pull" || log_red "failed to pull repo [$1]"
}

# Git pull for a repo or all repos
# $1: repo name or 'ALL'
function pull()
{
    for_each_repo pull_repo "$1" "pull"
}

# Git status for a single repository
# $1: repo path
function status_repo()
{
    repo_exists "$1" 'status'
    log_green "--> git status for repo [$1]"
    (cd "$1" && git status)
}

# Git status for a repo or all repos
# $1: repo name or 'ALL'
function status()
{
    for_each_repo status_repo "$1" "status"
}

# Create a symlink for a single file, handling conflicts
# $1: repo path
# $2: relative file path in repo
# $3: symlink path in destination
function process_symlink()
{
    local repo=$1 file=$2 slink=$3

    if [[ -e "$slink" ]]; then
        local current_target=$(readlink "$slink" 2>/dev/null)

        if [[ "$current_target" == "$repo/$file" ]]; then
            log_cyan "--> [$file] already symlinked"
            return
        fi

        if [[ $SKIP_CONFLICTS -eq 1 ]]; then
            log_yellow "(!) conflict symlink exists for [$file]"
            return
        fi

        if [[ $FIX_CONFLICTS -eq 0 ]]; then
            log_yellow "conflict for [$file] -> [$current_target]"
            read -p "fix $file? [y/(n)] " fix </dev/tty
            [[ $fix =~ [Nn] ]] && return
        else
            log_yellow "(!) fixing conflict for [$file]"
        fi

        run rm -f "$slink"
    fi

    ensure_dir "$(dirname "$slink")"
    run ln -s "$repo/$file" "$slink" || log_red "failed to symlink [$slink]"
    log_green "--> symlinked [$slink] -> [$repo/$file]"
}

# Create symlinks for all files in a single repository
# $1: repo path
function symlink_repo()
{
    local repo=$1
    repo_exists "$repo" 'symlink'

    log_magenta "--> symlinking repo [$repo]"

    if [[ $PREFIXED -eq 1 ]]; then
        find "$repo" -mindepth 1 -name '.git' -prune -o \
                                 -name '.'    -prune -o \
                                 -name '..'   -prune -o \
                                 -name '.*' -type f -print | while read -r fullpath; do
            local file="${fullpath#$repo/}"
            local slink="$DEST/$file"
            process_symlink "$repo" "$file" "$slink"
        done
    else
        find "$repo" -mindepth 1 -name '.git' -prune -o \
                                 -name '.*'   -prune -o \
                                 -type f -print | while read -r fullpath; do
            local file="${fullpath#$repo/}"
            local slink="$DEST/.$file"
            process_symlink "$repo" "$file" "$slink"
        done
    fi
}

# Create symlinks for a repo or all repos
# $1: repo name or 'ALL'
function symlink()
{
    for_each_repo symlink_repo "$1" "symlink"
}

# Check if a symlink is dangling and points to a repo, remove if so
# $1: symlink path
# $2: repo path
function check_and_remove_dangling()
{
    local slink=$1 repo=$2
    local link_target=$(readlink "$slink" 2>/dev/null)

    if [[ "$link_target" == "$repo/"* && ! -e "$link_target" ]]; then
        log_yellow "--> removing dangling symlink [$slink] -> [$link_target]"
        run rm -f "$slink"
        return 0
    fi
    return 1
}

# Remove dangling symlinks that point to a repository
# $1: file or directory path to check
# $2: repo name
function unlink()
{
    [[ -z "$1" || -z "$2" ]] && err "unlink requires two arguments"

    local target=$1 repo="$REPOS/$2"

    repo_exists "$repo" 'unlink'

    [[ ! -e "$target" && ! -L "$target" ]] && err "path $target does not exist"

    if [[ -L "$target" && ! -d "$target" ]]; then
        check_and_remove_dangling "$target" "$repo" || \
            log_cyan "--> [$target] is not a dangling symlink to repo [$repo]"
    elif [[ -d "$target" ]]; then
        log_magenta "--> checking directory [$target] for dangling symlinks to repo [$repo]"
        find "$target" -type l | while read -r slink; do
            check_and_remove_dangling "$slink" "$repo"
        done
    else
        log_cyan "--> [$target] is not a symlink"
    fi
}

# Add a file to a repo, git add it, and create a symlink
# $1: file path to track
# $2: repo name
function track()
{
    [[ -z "$1" || -z "$2" ]] && err "track requires two arguments"

    local repo="$REPOS/$2"
    local newfile
    [[ $PREFIXED -eq 1 ]] && newfile="$repo/$1" || newfile="$repo/${1#.}"

    repo_exists "$repo" 'track'

    [[ ! -e "$1" ]] && err "file $1 does not exist"

    if [[ -e "$newfile" ]]; then
        [[ $FIX_CONFLICTS -eq 0 ]] && err "file [$1] already exists in repo [$2]"
        log_red "overwriting [$1] which already exists in repo [$2]"
    fi

    log_green "--> adding [$newfile] to repo [$repo]"
    log_green "--> symlinked [$1] -> [$newfile]"

    ensure_dir "$(dirname "$newfile")"
    run mv -f "$1" "$newfile" || err "failed to move file [$1]"
    run ln -s "$newfile" "$1" || err "failed to create symlink [$1]"
    run sh -c "cd '$repo' && git add '${newfile#$repo/}'" || err "failed to git add [$newfile]"

    status "$2"
}

function usage()
{
    cat <<EOM
 Usage: nostalgic [options] <cmd> [args]

 Options:
   -n         dry run (no changes are performed)
   -s         skip conflicts
   -f         auto fix conflicts (default is interactive)
   -p         include files already starting with a dot
   -r <dir>   repo dir (default = \$HOME/dots)
   -d <dir>   symlink destination dir (default = \$HOME)

 Commands:
   clone <uri>            clone URI as a repo to be used
   list                   list cloned repos being used
   pull <repo>            git pull for the repo ('ALL' for all repos)
   status <repo>          git status for the repo ('ALL' for all repos)
   symlink <repo>         create symlinks for the repo ('ALL' for all repos)
   track <file> <repo>    copy the file to the repo, git add it, and symlink it
   unlink <path> <repo>   remove dangling symlinks (path can be file or dir)
EOM
    exit 1
}

command -v git >/dev/null 2>&1 || err "git not found"

while getopts "nsfpr:d:" opt; do
    case $opt in
        n) DRYRUN=1         ;;
        s) SKIP_CONFLICTS=1 ;;
        f) FIX_CONFLICTS=1  ;;
        p) PREFIXED=1       ;;
        r) REPOS=$OPTARG    ;;
        d) DEST=$OPTARG     ;;
        *) usage            ;;
    esac
done

shift $((OPTIND-1))

if [[ "${REPOS:0:1}" != "/" ]]; then
    err "repos dir '$REPOS' is not a full pathname"
fi

if [[ ! -d "$REPOS" ]]; then
    log_blue "repos dir '$REPOS' does not exist (creating)"
    mkdir -p "$REPOS"
fi

if [[ "${DEST:0:1}" != "/" ]]; then
    err "symlink destination dir '$DEST' is not a full pathname"
fi

if [[ ! -d "$DEST" ]]; then
    err "symlink destination dir '$DEST' does not exist"
fi

case $1 in
    clone)   shift; clone "$@"   ;;
    list)    list                ;;
    pull)    shift; pull "$@"    ;;
    status)  shift; status "$@"  ;;
    symlink) shift; symlink "$@" ;;
    track)   shift; track "$@"   ;;
    unlink)  shift; unlink "$@"  ;;
    *)       usage               ;;
esac

